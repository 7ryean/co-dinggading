
/* 

- search_autocomplete: 사용자가 자동 완성에서 검색 옵션을 클릭할 때 기록됩니다.
    >> yammer 의 자동완성 검색을 클릭 >> 추천을 클릭

- search_run: 사용자가 검색을 실행하고 검색 결과 페이지를 볼 때 기록됩니다.
    >>  사용자가 직접 엔터 or 결과검색 클릭

- search_click_X: 사용자가 검색 결과를 클릭할 때 기록됩니다. 1~10 범위의 X는 어떤 검색 결과가 클릭되었는지 설명합니다.
    >>  가장 관련성이 높은 결과가 포함된  결과 1-10 결과를 클릭 1번이 높으면 , 알고리즘 good

*/ 



-- 가장 먼저 yammer 검색자체에 사용자들이 만족을 하고 있는지 확인해보자
-- 만족도 지표는  정량적으로 구할 수 있는 사용자가 다음검색까지 걸린 시간의 분포로 확인해보려함 >> 사실 이게 만족도를 측정할 수 있을지 모르곘음...


/* 
-- 먼저 검색분포를 일별로 그룹화후 확인 >> 5일이내 검색할확률 86% 
   >> 두가지 검색으로 나눠 확인하면  search_run  93.9% /  search_autocomplete 78.1 %
   >> search_run이 높음 , but 두가지로 나눠 확인하면 run과 search_autocomplete 번갈아 검색은 고려 x 딲히 유의미한 결과 x
*/

WITH a AS (
SELECT user_id
      , event_name
      , occurred_at        AS day
      , LAG(occurred_at) OVER (PARTITION BY user_id ORDER BY occurred_at)   AS day2
FROM tutorial.yammer_events
WHERE event_name IN('search_run','search_autocomplete')
GROUP BY 1,2,3
ORDER BY 1,3 asc 
)

SELECT *
      , ROUND(cnt / sum(cnt) over() * 100,1)
FROM (
  SELECT CASE 
            WHEN day_diff <=5 then '0-5'
            WHEN day_diff <=10 then '6-10'
            WHEN day_diff <= 20 then '11-20'
            WHEN day_diff <= 30 then '21-30'
            ELSE '31+'
          END AS day_dist
  
        , count(*) AS cnt
  FROM(
    SELECT *
         ,EXTRACT(day FROM day - day2) AS day_diff
    FROM a
  ) day_diff
  WHERE day2 is not null 
  GROUP BY 1
)a



-- 5일이내에서 자르던가 / 시간별로 확인해야 할 것 같음   >> 1일 이내  76%

WITH a AS (
SELECT user_id
      , event_name
      , occurred_at        AS day
      , LAG(occurred_at) OVER (PARTITION BY user_id  ORDER BY occurred_at)   AS day2
FROM tutorial.yammer_events
WHERE event_name IN ('search_run' ,'search_autocomplete')
GROUP BY 1,2,3
ORDER BY 1,3 asc 
)

SELECT *  
      ,  SUM(cnt) OVER ()
      , ROUND(cnt /  SUM(cnt) OVER () *100 ,1) AS ratio
FROM (
  SELECT CASE 
            WHEN day_diff = 0 then '0day'
            WHEN day_diff = 1 then '1day'
            WHEN day_diff = 3 then '3day'
            WHEN day_diff = 4 then '4day'
            WHEN day_diff = 5 then '5day'
            ELSE '5+day+'
          END AS day_dist
  
        , count(*) AS cnt
  FROM(
    SELECT *
         ,EXTRACT(day FROM day - day2) AS day_diff
    FROM a
  ) day_diff
  WHERE day2 is not null 
  GROUP BY 1
) a 
ORDER BY 2



-- 검색자체의 만족도는 높다가 가정하고 다음 분석을 진행해보자함 
-- 접근자체가 잘못됐다고  여기서 느낌 새롭게 분석을 해보자  





-- 예상 1.yammer의 추천검색 성능이 좋으면 search_autocomplete 비율이 높을 것 
-- 예상 2.yammer의 검색의 결과가 관련성이 높은 알고리즘이면 search_click이 1-10의 클릭수가 1부터 클것
-- 이를 먼저 확인해보고 가설을 설정해보자 


WITH search_event AS (
SELECT user_id
       , occurred_at
       , CASE WHEN event_name LIKE '%search_click%' THEN 'search_click' ELSE event_name END AS search_step
FROM tutorial.yammer_events
WHERE event_type = 'engagement'
AND event_name LIKE '%search%'
ORDER BY 1 , 2
)

-- 우선 추천검색과 직접검색의 비율을 보기위해  search_run과 auto에 검색비율을 보려함  
-- autocomplete_ratio 58 % / autocomplete_ratio 42% 
-- 우선 추천검색의 클릭률이 더 높음 >> 근데 뛰어난 성능인지는 모르겠음,, 도메인 지식의 한계ㅜㅜ

SELECT *
      , (search_autocomplete /  total) AS autocomplete_ratio
      , (search_run / total)           AS run_ratio
FROM 
(
SELECT  CAST(count(*) AS FLOAT) AS total
      , sum(CASE WHEN search_step = 'search_autocomplete' THEN 1 END ) AS search_autocomplete
      , sum(CASE WHEN search_step = 'search_run' THEN 1 END )          AS search_run
      
FROM search_event
WHERE search_step <> 'search_click'
) a 




-- 이후 분석해볼 것 
-- 검색과 검색사이의 어떤 이벤트 들이 있고 어떤 과정 몇번의 과정을 거칠까 ?





